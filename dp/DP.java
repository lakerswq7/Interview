package dp;

public class DP {
/*
 * 如何判断是dp：
 * 0. 首先是不能排序，然后看问的问题，这三种情况一般都是dp：
 * 1. 找到一个最大值或者最小值
 * 2. 判断一些东西是不是可能的
 * 3. 统计所有可能的结果数
 * 总结：如果不能通过排序来优化，并且只是让你求一个数或者一个结果的话就很有可能是dp,最最关键的是你要觉得
 * 这个问题可以通过找转移方程从小问题一点一点求解上来
 * 
 * 4个要素：
 * 1. 状态， 存储小规模问题的结果
 * 2. 方程， 状态之间的联系，怎么通过小的状态来算大的状态
 * 3. 初始化， 最极限的小状态是什么
 * 4. 答案， 最大的那个状态是什么
 * 总结：dp关键在于状态的转移，关键在于通过原来的结果计算后面的结果，不一定要递归，循环扫描更好，复杂问题用递归，也是通过
 * 递归先算出结果，然后后面再算到这里的时候可以直接用
 * 
 * 4种类型：
 * 1. matrix dp	
 * 总结： 往往通过优化扫描的顺序能节省空间，实现空间的复用
 * 
 * 2. sequence dp
 * 总结： 往往是扫一遍的同时，扫他前面所有的，时间复杂度为O(n^2), 往往可以优化
 * 很多时候转移的关键是，要用前面已经判断过得结果，加上考虑最后一个词是否有效
 * 
 * 3. two sequences dp
 * 总结：	 往往是2维dp，即存储的小状态往往是二维的, 可以用2维数组，也可优化为滚动数组，即用两个一维数组滚动计算
 * 
 * 4. interval dp
 * 5. tree dp
 * 6. states compressing dp
 * 前三种比较多
 */
}
